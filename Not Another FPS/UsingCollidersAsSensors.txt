Trigger Colliders as sensors is really an appealing idea based on these (my opinion) advantages
1. The collider can be mounted to a GameObject instance. Not such a big advantage because one can always attach a MonoBehavior script, but...
2. Collision detection to simulate sensor detection is an engine function. I don't have to manually register objects that I want to track to simply find out if they are within my sensor range
3. If using Sphere colliders as sensor boundary, I can visualize and modify the sensor range in the game Editor, instead of looking into my source code.
4. I can use multiple Colliders for state transitions. In fact, currently this is how the zombies transition from random walk, then targeted walk, run, finally attack mode

However, I must pay attentions to the following drawbacks/pitfalls
1. Layer the sensors carefully and set the layers' collision matrix in the Project Settings. I cannot cram all Collider-based sensors into one layer. They will interact with other Colliders in the most unusual, and extremely painful to debug, fashion.
2. Colliders detect colliders, not the GameObject. Some of my zombies are animated, kinematic ragdolls, for reasons that are no more valid. Processing each of the ragdoll's colliders are both annoying and a waste of processing resource. At the price of one GameObject, I created a dedicated SensorTarget GameObject with the smallest sphere collider and the lightest Rigidbody weight allowed by Unity, and attach it at the center of the parent gameplay actor. Of course this leads to (3)
3. If using a dedicated SensorTarget GameObject, and your sensor need to query information about the parent GameObject, you need to implement a facade for the SensorTarget. This is an extra MonoBehaviour wrapper script.
4. Last but THE MOST ANNOYING PROBLEM usig Colliders as sensors: a destroyed or disabled target Collider WILL NOT GENERATE a OnCollisionExit or OnTriggerExit! I am still researching workarounds for this problem. The obvious suggestion is to register an event to establish 2 way communication between the target and the sensor source, just for handling the target's OnDestroy, or OnDisable. GREAT! Another suggestion that I find interesting is to disable the target's Rigidbody's collision detection prior to destruction. The timing can be tricky if there are physics interactions involved. But, since I am multi-layering, this can be a viable approach. Obvious limitations: won't work on static Colliders, so don't interact with walls.
5. Won't work like a radar, unless if you really want to depth-sort your contacts. Well, if you are trying to simulate a radar, then you have to do this, and start interacting with static collider obstructions.